/// Why doesn't this work on Travis under Java 7?
/// The same text does in Randoop's build.gradle file.
buildscript {
    dependencies {
        if (JavaVersion.current() >= JavaVersion.VERSION_11) {
            // Code formatting; defines targets "spotlessApply" and "spotlessCheck".
            // https://github.com/diffplug/spotless/tags ; see tags starting "gradle/"
            // Only works on JDK 11+.
            classpath 'com.diffplug.spotless:spotless-plugin-gradle:6.22.0'
        }
    }
}



plugins {
    id 'com.github.johnrengelman.shadow' version '7.1.2'
}

apply plugin: 'java'

ext {
    isJava8 = JavaVersion.current() == JavaVersion.VERSION_1_8

    isJava11plus = JavaVersion.current() >= JavaVersion.VERSION_11
    jsr308 = file(new File("..")).absolutePath
    cfPath = "${jsr308}/checker-framework"
    cfiPath = "${jsr308}/checker-framework-inference"
    afu = "${jsr308}/annotation-tools/annotation-file-utilities"
    picoPath = "${jsr308}/immutability"
    compilerArgsForRunningCF = [
        // Keep in sync with checker-framework/build.gradle.
        "--add-exports",
        "jdk.compiler/com.sun.tools.javac.api=ALL-UNNAMED",
        "--add-exports",
        "jdk.compiler/com.sun.tools.javac.code=ALL-UNNAMED",
        "--add-exports",
        "jdk.compiler/com.sun.tools.javac.file=ALL-UNNAMED",
        "--add-exports",
        "jdk.compiler/com.sun.tools.javac.main=ALL-UNNAMED",
        "--add-exports",
        "jdk.compiler/com.sun.tools.javac.model=ALL-UNNAMED",
        "--add-exports",
        "jdk.compiler/com.sun.tools.javac.processing=ALL-UNNAMED",
        "--add-exports",
        "jdk.compiler/com.sun.tools.javac.tree=ALL-UNNAMED",
        "--add-exports",
        "jdk.compiler/com.sun.tools.javac.util=ALL-UNNAMED",
        "--add-opens",
        "jdk.compiler/com.sun.tools.javac.comp=ALL-UNNAMED",
    ]
    if (isJava11plus) {
        apply plugin: 'com.diffplug.spotless'
        spotless {
            format 'misc', {
                target '*.md', '*.tex', '.gitignore', 'Makefile'
                indentWithSpaces(2)
                trimTrailingWhitespace()
            }

            java {
                target '**/*.java'
                googleJavaFormat().aosp()
                importOrder('com', 'jdk', 'lib', 'lombok', 'org', 'java', 'javax')
            }

            groovyGradle {
                target '**/*.gradle'
                greclipse()  // which formatter Spotless should use to format .gradle files.
                indentWithSpaces(4)
                trimTrailingWhitespace()
            }
        }
    }
}

if (isJava11plus) {
    apply plugin: 'com.diffplug.spotless'
    spotless {
        // Resolve the Spotless plugin dependencies from the buildscript repositories rather than the
        // project repositories.  That way the spotless plugin does not use the locally built version of
        // checker-qual as a dependency. Without this, errors like the follow are issued when running
        // a spotless task without a locally-built version of checker-qual.jar:
        // Could not determine the dependencies of task ':checker-qual:spotlessCheck'.
        //  > Could not create task ':checker-qual:spotlessJavaCheck'.
        //     > Could not create task ':checker-qual:spotlessJava'.
        //        > File signature can only be created for existing regular files, given:
        //          .../checker-framework/checker-qual/build/libs/checker-qual-3.25.1-SNAPSHOT.jar
        predeclareDepsFromBuildscript()
    }

    spotlessPredeclare {
        // Put all the formatters that have dependencies here.  Without this, errors like the following
        // will happen:
        // Could not determine the dependencies of task ':spotlessCheck'.
        //  > Could not create task ':spotlessJavaCheck'.
        //     > Could not create task ':spotlessJava'.
        //        > Add a step with [com.google.googlejavaformat:google-java-format:1.15.0] into the `spotlessPredeclare` block in the root project.
        java {
            googleJavaFormat()
        }
        groovyGradle {
            greclipse()
        }
    }
}

println '==================================='
println '            PICO Checker           '
println '==================================='
println ''
println '-------------------------------'
println 'Important Environment Variables'
println '-------------------------------'
println 'JSR308: ' + jsr308
println 'CF:     ' + cfPath
println 'CFI:    ' + cfiPath
println 'picoPath:' + picoPath

repositories {
    mavenCentral()
}

dependencies {
    implementation fileTree(dir: "${cfPath}/checker/dist", include: "checker.jar")
    implementation fileTree(dir: "${cfiPath}/dist", include: "checker-framework-inference.jar")
    // sat4j solver dependency
    implementation 'org.ow2.sat4j:org.ow2.sat4j.core:2.3.5'
    implementation 'org.ow2.sat4j:org.ow2.sat4j.maxsat:2.3.5'
    // The production code uses the SLF4J logging API at compile time
    implementation 'org.slf4j:slf4j-api:1.7.29'
    // CF test lib dependency
    testImplementation fileTree(dir: "${cfPath}/framework-test/build/libs", include: "framework-test-*.jar")
    testImplementation 'junit:junit:4.12'
}

sourceSets {
    main {
        java {
            srcDirs = ["src/main/java"]
        }

        resources {
            srcDirs = ["src/main/java"]
            exclude "**/*.java"
        }
    }

    test {
        java {
            // TODO: we shouldn't need source level dependency on CFITest
            srcDirs = [
                "src/test/java",
                "${cfiPath}/tests/checkers/inference/test"
            ]
        }
    }
}

compileJava {
    options.compilerArgs = [
        '-implicit:class',
        '-Awarns',
        '-Xmaxwarns',
        '10000',
    ]
}

afterEvaluate {
    // Create a task for each JUnit test class whose name is the same as the JUnit class name.
    sourceSets.test.allJava.filter { it.path.contains("${picoPath}/src/test/java") }.forEach { file ->
        String junitClassName = file.name.replaceAll(".java", "")
        String testName = junitClassName.replaceAll("Test", "")
        tasks.create(name: "${junitClassName}", type: Test) {
            description "Run ${testName} tests."
            include "**/${name}.class"
        }
    }

    // Configure JUnit tests
    tasks.withType(Test) {
        group 'Verification'

        systemProperties 'path.afu.scripts': "${afu}/scripts",
        'path.inference.script': "${cfiPath}/scripts/inference",
        JDK_JAR: "${cfPath}/checker/dist/jdk8.jar"

        environment "external_checker_classpath", "${picoPath}/build/classes/java/main:${picoPath}/build/resources/main"
        maxHeapSize = "1024m"
        if (isJava8) {
            jvmArgs "-Xbootclasspath/p:${cfiPath}/dist/javac.jar"
        } else {
            jvmArgs += compilerArgsForRunningCF
        }

        testLogging {
            // Always run the tests
            outputs.upToDateWhen { false }
            // The following prints out each time a test is passed.
            events "passed", "skipped", "failed", "standardOut", "standardError"

            // Show the found unexpected diagnostics and expected diagnostics not found.
            exceptionFormat "full"
            showExceptions true
            showCauses true
            showStackTraces true
            showStandardStreams true
        }

        // After each test, print a summary.
        afterSuite { desc, result ->
            if (desc.getClassName() != null) {
                long mils = result.getEndTime() - result.getStartTime()
                double seconds = mils / 1000.0

                println "Testsuite: ${desc.getClassName()}\n" +
                        "Tests run: ${result.testCount}, " +
                        "Failures: ${result.failedTestCount}, " +
                        "Skipped: ${result.skippedTestCount}, " +
                        "Time elapsed: ${seconds} sec\n"
            }
        }
    }
}

clean {
    delete "build",
            "testdata",
            "annotated",
            "default.jaif",
            fileTree("testinput") {include "**/*.class"}
}

// // Commented out because plugins section is commented out
// /* Configuration for formatting */
// googleJavaFormat {
//     // toolVersion '1.3'
//     options style: 'AOSP'
// }
// tasks.googleJavaFormat {
//     group 'Formatting'
//     description = "Reformat Java source code with Google-Java-format"
//     exclude 'testinput'
//     exclude 'testdata'
//     exclude 'annotated'
// }
// tasks.verifyGoogleJavaFormat {
//     group 'Formatting'
//     description = "Check Java source code is in Google-Java-format"
//     exclude 'testinput'
//     exclude 'testdata'
//     exclude 'annotated'
// }
